---
title: "P1-Inferencia"
author: "Nuria Oviedo, Marcos Lopez García"
date: "2024-10-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Ejercicio 1
```{r Librerias, message=FALSE, include = FALSE}
library(arulesCBA)
library(ggplot2)
library(summarytools)
library(tidyverse)
library(knitr)
```

```{r Importar datos, include = FALSE}
data("Mushroom")
```


Importamos los datos y mostramos los primeros y últimos datos en nuestra muestra para familiarizarnos con ellos.

```{r}
head(Mushroom)
```

```{r}
tail(Mushroom)
```


## Tamaño de los datos
```{r}
size <- dim(Mushroom)
n_obs <- size[1]
n_var <- size[2]
```
Este dataset, está compuesto de `r n_obs` observaciones y `r n_var` variables.

## Muestra del data set
Dado que tenemos un dataset con más de 1000 observaciones, hay que coger una muestra para hacer el análisis.

```{r}
set.seed(1234)
mushroom.muestra <- Mushroom[sample(1:n_obs, 1000, TRUE), ]
```

La muestra del dataset Mushroom es la siguiente:

```{r}
head(mushroom.muestra)
```

```{r}
tail(mushroom.muestra)
```


## Tipo de variables
```{r}
# Varialbes discretas
var_discreta <- length(which(sapply(Mushroom, class) == 'factor'))

# Variables continuas
var_continuas <- length(which(sapply(Mushroom, class) != 'factor'))

# Categorías de las variables
lapply(Mushroom, function(x) if(is.factor(x) | is.character(x)) unique(as.character(x)) else NULL)

# Variables tipo texto
i = 0
for (var in sapply(Mushroom, is.character)){
  if (var == TRUE){
    i = i + 1
  }
} 
```

Estudiando el tipo de variables que tiene este dataset, sabemos que hay `r var_discreta` variables discretas y `r var_continuas` variables continuas. De todas estas variables hay `r i` variables tipo texto.


## Variables irrelevantes
```{r echo = FALSE}
summary(Mushroom)
```
Viendo los datos del dataset, se puede ver que hay variables que se podrian considerar irrelevantes, como `VeilType`, ya que tiene solo una característica; y tambien se podria contar como irrelevante `Population`, ya que en sus características hay demasiados NA.

# Ejercicio 2
```{r}
summary(mushroom.muestra)
```

Dado que no hay variables continuas y todas son de tipo factor, solo podemos saber la fecuencia de la muestra:
```{r}
freq(mushroom.muestra)
```

Sin embargo hay varias varialbes que se pueden volver continuas. Como `RingNumber`o `RintType`. Tambien pueden ser booleanas como `Bruises`.
```{r}
mushroom.muestra$RingNumber.Numeric <- ifelse(mushroom.muestra$RingNumber == 'none', 0, 
                                       ifelse(mushroom.muestra$RingNumber == 'one', 1,
                                       ifelse(mushroom.muestra$RingNumber == 'two', 2, NA)))

mushroom.muestra$RingType.Numeric <- ifelse(mushroom.muestra$RingType == 'none', 0, 
                                     ifelse(mushroom.muestra$RingType == 'evanesent', 1,
                                     ifelse(mushroom.muestra$RingType == 'flaring', 2,
                                     ifelse(mushroom.muestra$RingType == 'large',3,
                                     ifelse(mushroom.muestra$RingType == 'pendant',4, NA)))))

mushroom.muestra$Bruises.bool <- ifelse(mushroom.muestra$Bruises == 'no', FALSE, 
                                       ifelse(mushroom.muestra$Bruises == 'bruise', TRUE, NA))
summary(mushroom.muestra)

```


# Ejercicio 3

Vamos a estudiar la variable `Spore` del dataset.
```{r}
tabla_frecuencias_type <- mushroom.muestra |>
  count(Spore) |>
  mutate(f = n / nrow(mushroom.muestra), N = cumsum(n), F = cumsum(f))
tabla_frecuencias_ordenada3 <- tabla_frecuencias_type |>
  arrange(desc(n))
tabla_frecuencias_ordenada3$F <- cumsum(tabla_frecuencias_ordenada3$f)
tabla_frecuencias_ordenada3$N <- cumsum(tabla_frecuencias_ordenada3$n)
print(tabla_frecuencias_ordenada3)
```

Por la tabla de frecuencias se puede ver que el color `buff` es el más frecuente, con una fracuencia de 0,187.

Resentando su frecuencia relativa obtenemos la siguiente tabla:
```{r}
mushroom.muestra  |> group_by(Spore) |>  summarise(Frequency = n()) |> mutate(Frequency = Frequency/sum(Frequency), Spore = reorder(Spore, -Frequency)) |> ggplot(aes(x = Spore, y = Frequency)) + geom_bar(stat = "identity", aes(fill = Frequency)) + scale_y_continuous(labels = scales::percent) + theme_bw() + labs(title = "Gráfico de barras con frecuencia relativa de Spore", x = "Color", y = "Frecuencia relativa") + scale_fill_gradient("Frecuencia", low = "olivedrab2", high = "burlywood3") + theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Se puede ver que el color `buff` tiene casi un 20% al igual que el color `pink`

```{r}
mushroom.muestra |>
  group_by(Spore) |>
  summarise(Frequency = n()) |>
  mutate(Spore = reorder(Spore, -Frequency)) |>
  ggplot(aes(x = Spore, y = Frequency)) +
  geom_bar(stat = "identity", aes(fill = Frequency)) +
  theme_bw() +
  labs(title = "Gráfico de barras con frecuencia absoluta de Spore",
       x = "Color",
       y = "Frecuencia absoluta") +
  scale_fill_gradient("Frecuencia", low = "olivedrab2", high = "burlywood3") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Al representar la frecuecia absoluta obtenermos el mismo resultado pero en cantidades, casi 200 hongos del color `buff` y `pink`. 

```{r}
ggplot(data = mushroom.muestra) +
  geom_bar(mapping = aes(x = Spore))
```


# Ejercicio 4
Como no tenermos varaibles continuas, voy a pasar a caracter la vaeiable de `GillColor`, los números que van con los distintos colores no tiene ninguna relacion, estan puestos por orden.

```{r}
mushroom.muestra$GillColor.numeric <- ifelse(mushroom.muestra$GillColor == 'buff', 0, 
ifelse(mushroom.muestra$GillColor == 'red', 1,
ifelse(mushroom.muestra$GillColor == 'gray', 2,
ifelse(mushroom.muestra$GillColor == 'chocolate',3,
ifelse(mushroom.muestra$GillColor == 'black',4, 
ifelse(mushroom.muestra$GillColor == 'brown', 5,
ifelse(mushroom.muestra$GillColor == 'orange', 6, 
ifelse(mushroom.muestra$GillColor == 'pink', 7,
ifelse(mushroom.muestra$GillColor == 'green', 8,
ifelse(mushroom.muestra$GillColor == 'purple', 9,
ifelse(mushroom.muestra$GillColor == 'white', 10, 
ifelse(mushroom.muestra$GillColor == 'yellow', 11, NA))))))))))))

mushroom.muestra |> descr(GillColor.numeric)
```

```{r}
tabla_frecuencias_gillcolor <- mushroom.muestra %>%
  count(GillColor.numeric) %>%
  mutate(f = n / nrow(mushroom.muestra))

tabla_frecuencias_gillcolor <- tabla_frecuencias_gillcolor %>%
  mutate(intervalo = cut(GillColor.numeric, breaks = pretty(GillColor.numeric, n = 10), right = FALSE)) %>%
  group_by(intervalo) %>%
  summarise(n = sum(n), 
            f = sum(f))

tabla_frecuencias_gillcolor <- tabla_frecuencias_gillcolor %>%
  mutate(N = cumsum(n),
         F = cumsum(f))

tabla_frecuencias_ordenada4 <- tabla_frecuencias_gillcolor %>%
  arrange(intervalo)

print(tabla_frecuencias_ordenada4)

```

Representacion de `GillColor.numeri` repecto a su frecuencia
```{r}
ggplot(data = mushroom.muestra) +
  geom_histogram(mapping = aes(x = GillColor.numeric), binwidth = 1) 
```

Si representamos su densidad tenemos la siguiente gráfica:
```{r}
ggplot(mushroom.muestra, aes(x = GillColor.numeric)) +
geom_density() +
ggtitle('Color de la muestra de Mushroom')
```

Ahora representamos su distribución.
```{r}
ggplot(data = mushroom.muestra) +
  geom_histogram(mapping = aes(x = log(GillColor.numeric)), binwidth = .1)
```


# Ejercicio 5
Para poder obtener el estimador de máxima verosimulitud de una forma practica hay que aplicar la siguiente formula:
$$
\hat \theta (x) = \max_{\theta \in \Theta} L(\theta|x)
$$
Por la representación de la disctribición se asume que una distribución normal, la cual tiene la siguiente forma 
$$
f(x_i;\mu, \sigma ^2) = {1 \over {\sqrt {2\pi \sigma ^2}}} \exp \left ( - { {(x_i - \mu)^2}\over {2\sigma^2}} \right )
$$

Teniendo esto sabemos que la fución de verosimilitud tiene la forma 
$$
L(\mu, \sigma^2|\mathbf x) = \prod_{i = 1}^n {{1 \over {\sqrt {2\pi \sigma ^2}}} \exp \left ( - { {(x_i - \mu)^2}\over {2\sigma^2}} \right )}
$$

Aplicamos el log-verosimilitud
$$
l(\mu, \sigma^2|\mathbf x) = \sum_{i = 1}^n \left [ - {1\over {2}} \log (2\pi \sigma^2) - {{(x_i - \mu)^2}\over {2\sigma^2}} \right ]
$$
Ahora se calculan las derivadas de $\mu$ y de $\sigma^2$ y las igualamos a cero
Primero calculamos la derivada respecto a la variable $\mu$
$$
{ {\partial l}\over {\partial \mu} } = \sum_{i = 1}^n {{x_i - \mu}\over {\sigma^2}} = 0 \implies \hat \mu = {1 \over n} \sum_{i = 1}^n x_i
$$

Ahora calculamos la derivada respecto a $\sigma^2$
$$
{ {\partial l}\over {\partial \sigma^2} } = -{n \over {2\sigma^2}} + {1 \over {2\sigma^4}} \sum_{i = 1}^n (x_i - \mu)^2 = 0 \implies \hat \sigma^2 = {1 \over n} \sum_{i = 1}^n (x_i - \hat \mu)^2
$$
Viendo esto podemos saber que los estimadores de máxima verosimilitud son la media muestral y la varianza muestral.

```{r}

mushroom_filtrado <- mushroom.muestra %>%
  filter(GillColor.numeric > 0) # Filtrar las observaciones con valores cero en `GillColor.numeric`

# transformación logarítmica
mushroom_filtrado$GillColor.log <- log(mushroom_filtrado$GillColor.numeric)

# EMV de la media y desviación estándar
emv_media_log <- mean(mushroom_filtrado$GillColor.log)
emv_desv_log <- sd(mushroom_filtrado$GillColor.log)

print(paste("Estimador de máxima verosimilitud de la media (EMV) de log(GillColor.numeric):", emv_media_log))
print(paste("Desviación estándar de log(GillColor.numeric):", emv_desv_log))

```


Antes de obtener el EVM, filtramos valores nulos de nuestros datos ya que no representan una parte relevante de la muestra  y mantenemos la integridad de nuestra muestra sin modificar los valores. 


```{r}

# Comparación gráfica

ggplot(mushroom_filtrado, aes(x = GillColor.log)) +
  geom_histogram(aes(y = ..density..), binwidth = 0.1, fill = "lightgreen", alpha = 0.7) +
  stat_function(fun = dnorm, args = list(mean = emv_media_log, sd = emv_desv_log))+
  xlab("log(GillColor.numeric)") +
  ylab("Densidad")

```

Este histograma muestra la distribucion de la variable "GillColor.numeric".
La curva negra superpuesta al histograma es una estimación de la densidad de probabilidad de la distribución de la variable transformada y nos permite estimar la probabilidad de que la variable tome  un valor determinado.


# Ejercicio 6


## Estimación de la Media utilizando el Método de los Momentos

Para estimar la media poblacional \( \mu \) de una variable aleatoria continua \( X \) que sigue una distribución normal \( N(\mu, \sigma^2) \), aplicamos el **método de los momentos**. Este método consiste en igualar el primer momento teórico de la distribución a su primer momento muestral.

Recordemos que el **primer momento teórico** (la media) de \( X \sim N(\mu, \sigma^2) \) es \( \mathbb{E}[X] = \mu \). Por otro lado, el **primer momento muestral** de una muestra \( x_1, x_2, \dots, x_n \) es:

\[
\bar{x} = \frac{1}{n} \sum_{i=1}^n x_i
\]

Para aplicar el método de los momentos, igualamos la media teórica con la media muestral:

\[
\mathbb{E}[X] = \bar{x} \Rightarrow \mu = \bar{x}
\]

Así, el estimador del primer momento (la media \( \mu \)) es simplemente la **media muestral** \( \hat{\mu} = \bar{x} \).

## Cálculo del Estimador en la Muestra

Dado un conjunto de datos muestrales \( x_1, x_2, \dots, x_n \), el valor del estimador \( \hat{\mu} \) es:

\[
\hat{\mu} = \frac{1}{n} \sum_{i=1}^n x_i
\]

## Intervalo de Confianza para la Media

Para construir un **intervalo de confianza del 95%** para la media \( \mu \), asumimos que la distribución de \( \hat{\mu} \) sigue una normal \( N\left(\mu, \frac{\sigma^2}{n}\right) \). Esto implica que un intervalo de confianza del 95% para \( \mu \) está dado por:

\[
\left( \hat{\mu} - z \cdot \frac{\sigma}{\sqrt{n}}, \hat{\mu} + z \cdot \frac{\sigma}{\sqrt{n}} \right)
\]

donde \( z \) es el valor crítico correspondiente al nivel de confianza (1.96 para el 95%), \( \sigma \) es la desviación estándar poblacional (o su estimador en la muestra), y \( n \) es el tamaño de la muestra. Si no conocemos \( \sigma \), podemos reemplazarlo con la desviación estándar muestral \( s \).

En la práctica, el intervalo de confianza del 95% para \( \mu \) en función de la desviación estándar muestral \( s \) y la media muestral \( \hat{\mu} \) se calcula como:

\[
\left( \hat{\mu} - 1.96 \cdot \frac{s}{\sqrt{n}}, \hat{\mu} + 1.96 \cdot \frac{s}{\sqrt{n}} \right)
\]

Este intervalo nos da un rango en el cual podemos estar 95% seguros de que se encuentra la verdadera media poblacional \( \mu \).





```{r}


# Función para calcular la media y el intervalo de confianza
calcular_media_y_intervalo <- function(mushroom.muestra) {
  # Tamaño de la muestra
  n <- length(mushroom.muestra)
  
  # Calcular la media muestral
  mu_hat <- mean(mushroom.muestra)
  
  # Calcular la desviación estándar muestral
  s <- sd(mushroom.muestra)
  
  # Calcular el valor crítico z para un intervalo de confianza del 95%
  z <- 1.96
  
  # Calcular el margen de error
  margen_error <- z * (s / sqrt(n))
  
  # Calcular el intervalo de confianza
  intervalo_confianza <- c(mu_hat - margen_error, mu_hat + margen_error)
  
  # Resultados
  return(list(media_muestral = mu_hat,
              desviacion_estandar = s,
              intervalo_confianza = intervalo_confianza))
}

# Ejemplo de uso
# Generar una muestra aleatoria de datos normales
set.seed(123)  # Para reproducibilidad
mushroom.muestra <- rnorm(30, mean = 50, sd = 10)  # Muestra de tamaño 30, media 50, desviación estándar 10

# Llamar a la función
resultados <- calcular_media_y_intervalo(mushroom.muestra)

# Imprimir resultados
print(paste("Media Muestral (mu_hat):", round(resultados$media_muestral, 2)))
print(paste("Desviación Estándar Muestral (s):", round(resultados$desviacion_estandar, 2)))
print(paste("Intervalo de Confianza del 95%:", 
            round(resultados$intervalo_confianza[1], 2), 
            "a", 
            round(resultados$intervalo_confianza[2], 2)))

```

# Ejercicio 7

Vamos a calcular la probabilidad de que el logaritmo de `GillColor.numeric` sea superior a la suma de la media y de la desviación estandar, para calcular la probabilidad hacemos una simulación de 100000 simulaciones para que sea lo más preciso posible.
```{r}
mu <- mom_media_log
sigma <- sqrt(mom_varianza_log)
valor_fijo <- mu + sigma

n_sim <- 1000000 

valores_simulados <- rnorm(n_sim, mean = mu, sd = sigma)
probabilidad <- mean(valores_simulados > valor_fijo)

cat("La probabilidad de que el valor sea superior a", valor_fijo, "es aproximadamente:", probabilidad, "\n")

```

# Ejercicio 8
Teniendo `GillColor.numeric` como variabe continua, se va a representar en base al `habitat` en el que se encuenta cada tipo de hongo.

```{r}
ggplot(mushroom.muestra, aes(x = log(GillColor.numeric), colour = Habitat)) +
  geom_density(lwd=2, linetype=1)
```


La imagen nos muestra la distribucion de los colores de nuestras setas para cada tipo de hábitat, y cada linea representa la densidad de probabilidad para cada hábitat.

Por ejemplo, podemos observar que  los hongos que viven en 'woods' tienen una distribución de 'GillColor' que se concentra en valores más altos, mientras que los hongos que viven en 'waste' tienen una distribución más dispersa. Recordemos que los colores fueron transformados a valores numéricos por lo que podemos concluir que los hongos que viven en woods tiennden a tener colores  como verde, morado blanco, mientras que hongos en waste no tienen una tendencia clara y los podemos encontrar decualquier color.





Relacion entre estas dos variables.
```{r}
df = mushroom.muestra %>% 
      select(GillColor.numeric,Habitat)%>%
      mutate(log.GillColor.numeric=log(GillColor.numeric))
```

Comparando sus boxplots obtenemos
```{r}
ggplot(mushroom.muestra, aes(x = Habitat, y = GillColor.numeric, fill = Habitat)) +
  geom_boxplot() +
  labs(title = "Distribución de Edad por Género",
       x = "Habitat",
       y = "Color") +
  theme_minimal()
```


En este caso usamos un boxplot para representar la misma conparacion que en el histograma anterior y confirmar las conclusiones obtenidas. 

Igual que en el histograma, podemos concluir en que los hongos que viven en 'waste' tienen una distribución dispersa mientras que por ejemplo en woods obtenemos valores más altos de la variable color.



Tabla de frecuencias
```{r}
kable(table(mushroom.muestra$GillColor.numeric, mushroom.muestra$Habitat))

kable(prop.table(table(mushroom.muestra$GillColor.numeric, mushroom.muestra$Habitat)), digits = 6)
```

En esta tabla podemos observar la frecuencia de distintos colores en diferentes hábitats.

Por ejemplo, en el hábitat woods podemos observar que predomina el color 7 (pink) con 83 observaciones, aunque tambien tenemos un número alto de observaciones en los colores 9 y 10 (morado y blanco).

En cambio, para el hábitat urbano (urban) podemos observar una falta de observaciones, lo que puede indicar un menor número de hongos y entre los cuales destacan los colores 5 y 7 (marron y rosa) con un valor de 12.


Datos sobre el conjunto de las dos variables
```{r}
lineal_1 <- mushroom.muestra |> 
  select(GillColor.numeric, Habitat) |> 
  with(lm(GillColor.numeric ~ Habitat))  
summary(lineal_1)
```


El análisis de regresión lineal realizado muestra que existe una relación significativa entre el color de las setas y el tipo de hábitat en el que viven.

El intercept de 6.13366 indica que el color referencia  es de 6.13366 unidades, es decir color naranja.

Habitatgrasses, Habitatleaves, Habitatpaths: Estos tres tipos de hábitat tienen una influencia negativa significativa en el color lo que significa que los hongos que viven en estos hábitats tienden a tener un colormás bajo que los hognos que viven en el hábitat de referencia. (rojo,gris,  marron, negro, chocolate, naranja)

Habitatmeadows: El efecto del hábitat de prados sobre el color de las setas es  no es tan fuerte como en los otros hábitats.

Habitaturban, Habitatwaste: Estos dos tipos de hábitat no tienen un impacto significativo en el color de las setas.

# Ejercicio 9

Para analizar si el hábitat tiene un efecto significativo sobre el color de las branquias de los hongos, planteamos un contraste de hipótesis en el que la hipótesis nula establece que el color de las branquias (GillColor.numeric) no varía de manera significativa entre hábitats, mientras que la hipótesis alternativa sugiere que sí existen diferencias notables en el color según el hábitat.

Emplearemos un análisis ANOVA para comparar las medias de nuestra variable continua con de varios grupos categóricos, en este caso, los distintos hábitats. 


```{r}
anova_result <- aov(GillColor.numeric ~ Habitat, data = mushroom.muestra)
summary(anova_result)

```



